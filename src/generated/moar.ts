import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from '@protobuf-ts/runtime'
import {
  MESSAGE_TYPE,
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from '@protobuf-ts/runtime'
// @generated by protobuf-ts 2.0.4-alpha.0 with parameter client_none,long_type_string,generate_dependencies
// @generated from protobuf file "moar.proto" (package "moarpb", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc'

/**
 * @generated from  Protobuf message moarpb.GetModuleRequest.
 */
export interface GetModuleRequest {
  /**
   * @generated from  protobuf field: string moduleName = 1;
   */
  moduleName: string
}
/**
 * @generated from  Protobuf message moarpb.GetModuleResponse.
 */
export interface GetModuleResponse {
  /**
   * @generated from  protobuf field: moarpb.Module module = 1;
   */
  module?: Module
}
/**
 * @generated from  Protobuf message moarpb.GetUrlRequest.
 */
export interface GetUrlRequest {
  /**
   * @generated from  protobuf field: string moduleName = 1;
   */
  moduleName: string
  /**
   * @generated from  Protobuf oneof: versionSelector.
   */
  versionSelector:
    | {
        oneofKind: 'versionConstraint'
        /**
         * @generated from  protobuf field: string versionConstraint = 2;
         */
        versionConstraint: string
      }
    | {
        oneofKind: 'version'
        /**
         * @generated from  protobuf field: string version = 3;
         */
        version: string
      }
    | {
        oneofKind: undefined
      }
}
/**
 * @generated from  Protobuf message moarpb.VersionResource.
 */
export interface VersionResource {
  /**
   * @generated from  protobuf field: string uri = 1;
   */
  uri: string
  /**
   * @generated from  protobuf field: string name = 2;
   */
  name: string
  /**
   * @generated from  protobuf field: string contentType = 3;
   */
  contentType: string
}
/**
 * @generated from  Protobuf message moarpb.GetUrlResponse.
 */
export interface GetUrlResponse {
  /**
   * @generated from  protobuf field: repeated moarpb.VersionResource resources = 1;
   */
  resources: VersionResource[]
  /**
   * @generated from  protobuf field: moarpb.Module module = 2;
   */
  module?: Module
  /**
   * @generated from  protobuf field: string selectedVersion = 3;
   */
  selectedVersion: string
}
/**
 * @generated from  Protobuf message moarpb.CreateModuleRequest.
 */
export interface CreateModuleRequest {
  /**
   * @generated from  protobuf field: string moduleName = 1;
   */
  moduleName: string
  /**
   * @generated from  protobuf field: string author = 2;
   */
  author: string
  /**
   * @generated from  protobuf field: string language = 3;
   */
  language: string
}
/**
 * @generated from  Protobuf message moarpb.CreateModuleResponse.
 */
export interface CreateModuleResponse {}
/**
 * @generated from  Protobuf message moarpb.DeleteModuleRequest.
 */
export interface DeleteModuleRequest {
  /**
   * @generated from  protobuf field: string moduleName = 1;
   */
  moduleName: string
}
/**
 * @generated from  Protobuf message moarpb.DeleteModuleResponse.
 */
export interface DeleteModuleResponse {}
/**
 * @generated from  Protobuf message moarpb.UploadVersionRequest.
 */
export interface UploadVersionRequest {
  /**
   * @generated from  protobuf field: string moduleName = 1;
   */
  moduleName: string
  /**
   * @generated from  protobuf field: string version = 2;
   */
  version: string
  /**
   * @generated from  protobuf field: repeated moarpb.File files = 3;
   */
  files: File[]
}
/**
 * @generated from  Protobuf message moarpb.UploadVersionResponse.
 */
export interface UploadVersionResponse {}
/**
 * @generated from  Protobuf message moarpb.DeleteVersionRequest.
 */
export interface DeleteVersionRequest {
  /**
   * @generated from  protobuf field: string moduleName = 1;
   */
  moduleName: string
  /**
   * @generated from  protobuf field: string version = 2;
   */
  version: string
}
/**
 * @generated from  Protobuf message moarpb.DeleteVersionResponse.
 */
export interface DeleteVersionResponse {}
/**
 * @generated from  Protobuf message moarpb.Module.
 */
export interface Module {
  /**
   * @generated from  protobuf field: string name = 1;
   */
  name: string
  /**
   * @generated from  protobuf field: repeated moarpb.Version versions = 2;
   */
  versions: Version[]
  /**
   * @generated from  protobuf field: string author = 3;
   */
  author: string
  /**
   * @generated from  protobuf field: string language = 4;
   */
  language: string
}
/**
 * @generated from  Protobuf message moarpb.Version.
 */
export interface Version {
  /**
   * @generated from  protobuf field: string name = 1;
   */
  name: string
  /**
   * @generated from  protobuf field: repeated moarpb.File files = 2;
   */
  files: File[]
}
/**
 * @generated from  Protobuf message moarpb.File.
 */
export interface File {
  /**
   * @generated from  protobuf field: string name = 1;
   */
  name: string
  /**
   * @generated from  protobuf field: string mimeType = 2;
   */
  mimeType: string
  /**
   * @generated from  protobuf field: bytes data = 3;
   */
  data: Uint8Array
}
// @generated message type with reflection information, may provide speed optimized methods
class GetModuleRequest$Type extends MessageType<GetModuleRequest> {
  constructor() {
    super('moarpb.GetModuleRequest', [
      { no: 1, name: 'moduleName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(value?: PartialMessage<GetModuleRequest>): GetModuleRequest {
    const message = { moduleName: '' }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<GetModuleRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetModuleRequest
  ): GetModuleRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string moduleName */ 1:
          message.moduleName = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GetModuleRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string moduleName = 1; */
    if (message.moduleName !== '') writer.tag(1, WireType.LengthDelimited).string(message.moduleName)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.GetModuleRequest.
 */
export const GetModuleRequest = new GetModuleRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetModuleResponse$Type extends MessageType<GetModuleResponse> {
  constructor() {
    super('moarpb.GetModuleResponse', [{ no: 1, name: 'module', kind: 'message', T: () => Module }])
  }
  create(value?: PartialMessage<GetModuleResponse>): GetModuleResponse {
    const message = {}
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<GetModuleResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetModuleResponse
  ): GetModuleResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* moarpb.Module module */ 1:
          message.module = Module.internalBinaryRead(reader, reader.uint32(), options, message.module)
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GetModuleResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* moarpb.Module module = 1; */
    if (message.module)
      Module.internalBinaryWrite(
        message.module,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.GetModuleResponse.
 */
export const GetModuleResponse = new GetModuleResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetUrlRequest$Type extends MessageType<GetUrlRequest> {
  constructor() {
    super('moarpb.GetUrlRequest', [
      { no: 1, name: 'moduleName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'versionConstraint',
        kind: 'scalar',
        oneof: 'versionSelector',
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: 'version', kind: 'scalar', oneof: 'versionSelector', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(value?: PartialMessage<GetUrlRequest>): GetUrlRequest {
    const message = { moduleName: '', versionSelector: { oneofKind: undefined } }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<GetUrlRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetUrlRequest
  ): GetUrlRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string moduleName */ 1:
          message.moduleName = reader.string()
          break
        case /* string versionConstraint */ 2:
          message.versionSelector = {
            oneofKind: 'versionConstraint',
            versionConstraint: reader.string(),
          }
          break
        case /* string version */ 3:
          message.versionSelector = {
            oneofKind: 'version',
            version: reader.string(),
          }
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GetUrlRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string moduleName = 1; */
    if (message.moduleName !== '') writer.tag(1, WireType.LengthDelimited).string(message.moduleName)
    /* string versionConstraint = 2; */
    if (message.versionSelector.oneofKind === 'versionConstraint')
      writer.tag(2, WireType.LengthDelimited).string(message.versionSelector.versionConstraint)
    /* string version = 3; */
    if (message.versionSelector.oneofKind === 'version')
      writer.tag(3, WireType.LengthDelimited).string(message.versionSelector.version)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.GetUrlRequest.
 */
export const GetUrlRequest = new GetUrlRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class VersionResource$Type extends MessageType<VersionResource> {
  constructor() {
    super('moarpb.VersionResource', [
      { no: 1, name: 'uri', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'contentType', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(value?: PartialMessage<VersionResource>): VersionResource {
    const message = { uri: '', name: '', contentType: '' }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<VersionResource>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VersionResource
  ): VersionResource {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string uri */ 1:
          message.uri = reader.string()
          break
        case /* string name */ 2:
          message.name = reader.string()
          break
        case /* string contentType */ 3:
          message.contentType = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: VersionResource,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string uri = 1; */
    if (message.uri !== '') writer.tag(1, WireType.LengthDelimited).string(message.uri)
    /* string name = 2; */
    if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name)
    /* string contentType = 3; */
    if (message.contentType !== '') writer.tag(3, WireType.LengthDelimited).string(message.contentType)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.VersionResource.
 */
export const VersionResource = new VersionResource$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetUrlResponse$Type extends MessageType<GetUrlResponse> {
  constructor() {
    super('moarpb.GetUrlResponse', [
      {
        no: 1,
        name: 'resources',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => VersionResource,
      },
      { no: 2, name: 'module', kind: 'message', T: () => Module },
      { no: 3, name: 'selectedVersion', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(value?: PartialMessage<GetUrlResponse>): GetUrlResponse {
    const message = { resources: [], selectedVersion: '' }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<GetUrlResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetUrlResponse
  ): GetUrlResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated moarpb.VersionResource resources */ 1:
          message.resources.push(VersionResource.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* moarpb.Module module */ 2:
          message.module = Module.internalBinaryRead(reader, reader.uint32(), options, message.module)
          break
        case /* string selectedVersion */ 3:
          message.selectedVersion = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GetUrlResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated moarpb.VersionResource resources = 1; */
    for (let i = 0; i < message.resources.length; i++)
      VersionResource.internalBinaryWrite(
        message.resources[i]!,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* moarpb.Module module = 2; */
    if (message.module)
      Module.internalBinaryWrite(
        message.module,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string selectedVersion = 3; */
    if (message.selectedVersion !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.selectedVersion)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.GetUrlResponse.
 */
export const GetUrlResponse = new GetUrlResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateModuleRequest$Type extends MessageType<CreateModuleRequest> {
  constructor() {
    super('moarpb.CreateModuleRequest', [
      { no: 1, name: 'moduleName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'author', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'language', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }
  create(value?: PartialMessage<CreateModuleRequest>): CreateModuleRequest {
    const message = { moduleName: '', author: '', language: '' }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<CreateModuleRequest>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateModuleRequest
  ): CreateModuleRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string moduleName */ 1:
          message.moduleName = reader.string()
          break
        case /* string author */ 2:
          message.author = reader.string()
          break
        case /* string language */ 3:
          message.language = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }

  override internalBinaryWrite(
    message: CreateModuleRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string moduleName = 1; */
    if (message.moduleName !== '') writer.tag(1, WireType.LengthDelimited).string(message.moduleName)
    /* string author = 2; */
    if (message.author !== '') writer.tag(2, WireType.LengthDelimited).string(message.author)
    /* string language = 3; */
    if (message.language !== '') writer.tag(3, WireType.LengthDelimited).string(message.language)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.CreateModuleRequest.
 */
export const CreateModuleRequest = new CreateModuleRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateModuleResponse$Type extends MessageType<CreateModuleResponse> {
  constructor() {
    super('moarpb.CreateModuleResponse', [])
  }

  override create(value?: PartialMessage<CreateModuleResponse>): CreateModuleResponse {
    const message = {}
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<CreateModuleResponse>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateModuleResponse
  ): CreateModuleResponse {
    return target ?? this.create()
  }

  override internalBinaryWrite(
    message: CreateModuleResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.CreateModuleResponse.
 */
export const CreateModuleResponse = new CreateModuleResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DeleteModuleRequest$Type extends MessageType<DeleteModuleRequest> {
  constructor() {
    super('moarpb.DeleteModuleRequest', [
      { no: 1, name: 'moduleName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }

  override create(value?: PartialMessage<DeleteModuleRequest>): DeleteModuleRequest {
    const message = { moduleName: '' }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<DeleteModuleRequest>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteModuleRequest
  ): DeleteModuleRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string moduleName */ 1:
          message.moduleName = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }

  override internalBinaryWrite(
    message: DeleteModuleRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string moduleName = 1; */
    if (message.moduleName !== '') writer.tag(1, WireType.LengthDelimited).string(message.moduleName)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.DeleteModuleRequest.
 */
export const DeleteModuleRequest = new DeleteModuleRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DeleteModuleResponse$Type extends MessageType<DeleteModuleResponse> {
  constructor() {
    super('moarpb.DeleteModuleResponse', [])
  }

  override create(value?: PartialMessage<DeleteModuleResponse>): DeleteModuleResponse {
    const message = {}
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<DeleteModuleResponse>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteModuleResponse
  ): DeleteModuleResponse {
    return target ?? this.create()
  }

  override internalBinaryWrite(
    message: DeleteModuleResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.DeleteModuleResponse.
 */
export const DeleteModuleResponse = new DeleteModuleResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UploadVersionRequest$Type extends MessageType<UploadVersionRequest> {
  constructor() {
    super('moarpb.UploadVersionRequest', [
      { no: 1, name: 'moduleName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'version', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'files', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => File },
    ])
  }

  override create(value?: PartialMessage<UploadVersionRequest>): UploadVersionRequest {
    const message = { moduleName: '', version: '', files: [] }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<UploadVersionRequest>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UploadVersionRequest
  ): UploadVersionRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string moduleName */ 1:
          message.moduleName = reader.string()
          break
        case /* string version */ 2:
          message.version = reader.string()
          break
        case /* repeated moarpb.File files */ 3:
          message.files.push(File.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }

  override internalBinaryWrite(
    message: UploadVersionRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string moduleName = 1; */
    if (message.moduleName !== '') writer.tag(1, WireType.LengthDelimited).string(message.moduleName)
    /* string version = 2; */
    if (message.version !== '') writer.tag(2, WireType.LengthDelimited).string(message.version)
    /* repeated moarpb.File files = 3; */
    for (let i = 0; i < message.files.length; i++)
      File.internalBinaryWrite(
        message.files[i]!,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.UploadVersionRequest.
 */
export const UploadVersionRequest = new UploadVersionRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UploadVersionResponse$Type extends MessageType<UploadVersionResponse> {
  constructor() {
    super('moarpb.UploadVersionResponse', [])
  }

  override create(value?: PartialMessage<UploadVersionResponse>): UploadVersionResponse {
    const message = {}
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<UploadVersionResponse>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UploadVersionResponse
  ): UploadVersionResponse {
    return target ?? this.create()
  }

  override internalBinaryWrite(
    message: UploadVersionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.UploadVersionResponse.
 */
export const UploadVersionResponse = new UploadVersionResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DeleteVersionRequest$Type extends MessageType<DeleteVersionRequest> {
  constructor() {
    super('moarpb.DeleteVersionRequest', [
      { no: 1, name: 'moduleName', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'version', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }

  override create(value?: PartialMessage<DeleteVersionRequest>): DeleteVersionRequest {
    const message = { moduleName: '', version: '' }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<DeleteVersionRequest>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteVersionRequest
  ): DeleteVersionRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string moduleName */ 1:
          message.moduleName = reader.string()
          break
        case /* string version */ 2:
          message.version = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }

  override internalBinaryWrite(
    message: DeleteVersionRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string moduleName = 1; */
    if (message.moduleName !== '') writer.tag(1, WireType.LengthDelimited).string(message.moduleName)
    /* string version = 2; */
    if (message.version !== '') writer.tag(2, WireType.LengthDelimited).string(message.version)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.DeleteVersionRequest.
 */
export const DeleteVersionRequest = new DeleteVersionRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DeleteVersionResponse$Type extends MessageType<DeleteVersionResponse> {
  constructor() {
    super('moarpb.DeleteVersionResponse', [])
  }

  override create(value?: PartialMessage<DeleteVersionResponse>): DeleteVersionResponse {
    const message = {}
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<DeleteVersionResponse>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteVersionResponse
  ): DeleteVersionResponse {
    return target ?? this.create()
  }

  override internalBinaryWrite(
    message: DeleteVersionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.DeleteVersionResponse.
 */
export const DeleteVersionResponse = new DeleteVersionResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Module$Type extends MessageType<Module> {
  constructor() {
    super('moarpb.Module', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'versions', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Version },
      { no: 3, name: 'author', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'language', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ])
  }

  override create(value?: PartialMessage<Module>): Module {
    const message = { name: '', versions: [], author: '', language: '' }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Module>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Module
  ): Module {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* repeated moarpb.Version versions */ 2:
          message.versions.push(Version.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* string author */ 3:
          message.author = reader.string()
          break
        case /* string language */ 4:
          message.language = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }

  override internalBinaryWrite(message: Module, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* repeated moarpb.Version versions = 2; */
    for (let i = 0; i < message.versions.length; i++)
      Version.internalBinaryWrite(
        message.versions[i]!,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string author = 3; */
    if (message.author !== '') writer.tag(3, WireType.LengthDelimited).string(message.author)
    /* string language = 4; */
    if (message.language !== '') writer.tag(4, WireType.LengthDelimited).string(message.language)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.Module.
 */
export const Module = new Module$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Version$Type extends MessageType<Version> {
  constructor() {
    super('moarpb.Version', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'files', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => File },
    ])
  }

  override create(value?: PartialMessage<Version>): Version {
    const message = { name: '', files: [] }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Version>(this, message, value)
    return message
  }

  override internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Version
  ): Version {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* repeated moarpb.File files */ 2:
          message.files.push(File.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }

  override internalBinaryWrite(message: Version, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* repeated moarpb.File files = 2; */
    for (let i = 0; i < message.files.length; i++)
      File.internalBinaryWrite(
        message.files[i]!,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.Version.
 */
export const Version = new Version$Type()
// @generated message type with reflection information, may provide speed optimized methods
class File$Type extends MessageType<File> {
  constructor() {
    super('moarpb.File', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'mimeType', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'data', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
    ])
  }

  override create(value?: PartialMessage<File>): File {
    const message = { name: '', mimeType: '', data: new Uint8Array(0) }
    Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<File>(this, message, value)
    return message
  }

  override internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: File): File {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* string mimeType */ 2:
          message.mimeType = reader.string()
          break
        case /* bytes data */ 3:
          message.data = reader.bytes()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d)
      }
    }
    return message
  }

  override internalBinaryWrite(message: File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* string mimeType = 2; */
    if (message.mimeType !== '') writer.tag(2, WireType.LengthDelimited).string(message.mimeType)
    /* bytes data = 3; */
    if (message.data.length) writer.tag(3, WireType.LengthDelimited).bytes(message.data)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType  For protobuf message moarpb.File.
 */
export const File = new File$Type()
/**
 * @generated ServiceType  For protobuf service moarpb.ModuleRegistry.
 */
export const ModuleRegistry = new ServiceType('moarpb.ModuleRegistry', [
  { name: 'GetUrl', options: {}, I: GetUrlRequest, O: GetUrlResponse },
  { name: 'CreateModule', options: {}, I: CreateModuleRequest, O: CreateModuleResponse },
  { name: 'GetModule', options: {}, I: GetModuleRequest, O: GetModuleResponse },
  { name: 'DeleteModule', options: {}, I: DeleteModuleRequest, O: DeleteModuleResponse },
  { name: 'UploadVersion', options: {}, I: UploadVersionRequest, O: UploadVersionResponse },
  { name: 'DeleteVersion', options: {}, I: DeleteVersionRequest, O: DeleteVersionResponse },
])
